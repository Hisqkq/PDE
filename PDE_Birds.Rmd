---
title: "Projet stat pour données environnementales"
author: "Alexandre Leys, Baptiste Gerbouin, Hamad Tria, Louis Delignac, Théo Lavandier"
date: "`r format(Sys.Date(), '%d %B, %Y')`"
output:
  html_document:
    code_folding: hide
    code_download: true
    theme: united
    highlight: tango
    df_print: paged
    toc: true
    toc_float: true
    toc_depth: 2
  # pdf_document:
  #   toc: true
  #   toc_depth: 2
  #   number_sections: true
  #   df_print: kable
  #   highlight: tango
---

<style>
  .tocify-extend-page {
    display: none;
  }
</style>

# Introduction


Dans le cadre de notre projet de statistiques, nous devons travailler sur un jeu de données environnementales.
Ce jeu de données est composé de plusieurs fichiers qui contiennent des informations sur les oiseaux, les stations de mesure, les traits des oiseaux, les sites de mesure, les régimes alimentaires des oiseaux, les statuts de l'IUCN et la biodiversité.
Nous avons décidé de nous concentrer sur les oiseaux et les stations de mesure.
Nous avons donc nettoyé les données, effectué des analyses exploratoires et des analyses multivariées pour mieux comprendre les relations entre les différentes variables.
Nous avons également créé des cartes interactives pour visualiser les données.

```{r setup, message=FALSE, echo=FALSE}
# Packages de gestion des données
library(tidyverse)
library(sf)

# Packages pour visualisation des données
library(ggplot2)
library(ggspatial)
library(kableExtra)
library(lattice)
library(plotly)

# Packages pour visualisation de cartes intéractives
library(leaflet)
library(leafpop)
library(leaflet.extras)

#ACP
library(FactoMineR)
library(factoextra)

knitr::opts_chunk$set(out.width = "100%", echo = TRUE)
```

Pour commencer, nous allons charger les données et les explorer pour mieux comprendre leur structure.
Dans un premier temps, nous allons ajouter une colonne à notre DataFrame qui contient les noms latins des oiseaux.
```{r}
oiseaux <- read.csv("data/birds/Oiseaux_up_to_2023.csv", header = TRUE, sep = "\t")
# CRÉER UNE NOUVELLE COLONNE DANS LE DATAFRAME OISEAUX QUI CONTIENT LE NOM LATIN DE L'OISEAU
my_split <- function(array, str = " \\| ") {
  out <- rep(NA, length(array))
  for (i in 1:length(array)) {
    out[i] <- unlist(strsplit(array[i], str))[1]
  }
  return(out)
}

only_latin <- my_split(as.vector(oiseaux$Nom_Taxon_Cite))

oiseaux$latin <- only_latin
oiseaux$annee <- as.numeric(substr(oiseaux$Date, 1, 4))
```


Par la suite, nous allons explorer les données pour mieux comprendre la distribution des espèces d'oiseaux observées.
Voici un tableau qui montre les 10 espèces d'oiseaux les plus fréquemment observées dans l'ensemble des données.
```{r}
# LES ESPÈCES D'OISEAUX LES PLUS FRÉQUENTES OBSERVÉES DANS L'ENSEMBLE DES DONNÉES
as.data.frame(sort(table(oiseaux$latin), decreasing = TRUE)[1:10])
```

Nous allons maintenant explorer la fréquence des espèces d'oiseaux observées dans l'ensemble des données par année.
Voici, par ordre alphabétique, le tableau mettant en évidence cette fréquence.

```{r}
# FRÉQUENCE DES ESPÈCES D'OISEAUX OBSERVÉES DANS L'ENSEMBLE DES DONNÉES PAR ANNÉE
Annee <- my_split(as.vector(oiseaux$Date), str = "-")
oiseaux$Annee <- as.factor(Annee)
as.data.frame.matrix(table(oiseaux$latin, oiseaux$Annee))
```


Dans cette partie, nous allons explorer la mesure de la diversité à travers différentes mesures.
Nous nous intéresserons uniquement au MOS11, c'est à dire les surfaces artificialisées. On prend comme buffer size 500m.

Dans un premier temps, nous allons utiliser la proportion d’espèces différentes observées dans une station pour mesurer la diversité. Dans un deuxième temps, nous allons utiliser l’entropie de Shannon et enfin l'indice de Simpson.

```{r, message=FALSE, warning=FALSE}
## Analyse de diversité par rapport à MOS11 et par année

denombrement <- oiseaux %>%
  group_by(Code_Maille, annee, latin) %>%
  summarise(sum = sum(Denombrement_min, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(Code_Maille))

denombrement$p <- rep(NA, nrow(denombrement))
for (i in 1:nrow(denombrement)) {
  numerator <- denombrement$sum[i]
  denominator <-
    sum(denombrement$sum[which(denombrement$Code_Maille == denombrement$Code_Maille[i]
                               & denombrement$annee == denombrement$annee[i])])
  denombrement$p[i] <- numerator / denominator
}

index <- denombrement %>%
  group_by(Code_Maille, annee = factor(annee)) %>%
  summarise(D1 = sum(p > 0, na.rm = TRUE),
            D2 = exp(-sum(p * log(p))),
            D3 = 1 / sum(p^2), .groups = "drop") %>%
  arrange(desc(Code_Maille))

LUP <- read.csv("data/birds/LandUsePer_BM_2023_cartoISea.csv", header = TRUE)
index$MOS11 <- rep(NA, nrow(index))
for (i in 1:nrow(index)) {
  index$MOS11[i] <- LUP$MOS11[which(index$Code_Maille[i] == LUP$ID & LUP$BufferSize == 500)]
}
```

Voici le graphique qui montre la relation entre la diversité et MOS11 pour chaque année expliqué par la proportion d'espèces.
```{r, message=FALSE, warning=FALSE, error=FALSE}
ggplot(index, aes(x = MOS11, y = D1, color = as.factor(annee))) +
  geom_point(size = 2) +
  geom_smooth(method = "auto", se = TRUE, color = "black", alpha = 0.2) +
  labs(title = " Proportion d’espèces en fonction de MOS11",
       x = "MOS11",
       y = "Nombre d\'espèces") +
  theme_minimal() +
  labs(colour = "Année") +
  theme(legend.position = "bottom")
```

Ceci est le graphique qui montre la relation entre la diversité et MOS11 pour chaque année expliqué par l'entropie de Shannon.
```{r, message=FALSE, warning=FALSE, error=FALSE}
ggplot(index, aes(x = MOS11, y = D2, color = as.factor(annee))) +
  geom_point(size = 2) +
  geom_smooth(method = "auto", se = TRUE, color = "black", alpha = 0.2) +
  labs(title = "Indice de Shanon en fonction de MOS11",
       x = "MOS11",
       y = "Indice de Shanon") +
  theme_minimal() +
  labs(colour = "Année") +
  theme(legend.position = "bottom")
```

Ceci est le graphique qui montre la relation entre la diversité et MOS11 pour chaque année expliqué par l'indice de Simpson.
```{r, message=FALSE, warning=FALSE, error=FALSE}
ggplot(index, aes(x = MOS11, y = D3, color = as.factor(annee))) +
  geom_point(size = 2) +
  geom_smooth(method = "auto", se = TRUE, color = "black", alpha = 0.2) +
  labs(title = "Indice de Simpson en fonction de MOS11",
       x = "MOS11",
       y = "Indice de Simpson") +
  theme_minimal() +
  labs(colour = "Année") +
  theme(legend.position = "bottom")
```

La tendance globale est l'augmentation de la diversité au début de la courbe jusqu'à atteindre un maximum puis une baisse quand le MOS11 augmente davantage. C'est-à-dire que, moins les sols sont artificialisés, plus la diversité est grande avec une diversité maximale atteinte quand le milieu est à la fois artificialisé mais présente également des surfaces non artificialisées. 



```{r}
oiseaux <- read.csv("data/birds/Oiseaux_up_to_2023.csv", header = TRUE, sep = "\t")
LUP <- read.csv("data/birds/LandUsePer_BM_2023_cartoISea.csv", header = TRUE)
```

```{r}
# CRÉER UNE NOUVELLE COLONNE DANS LE DATAFRAME OISEAUX QUI CONTIENT LE NOM LATIN DE L'OISEAU
# LE NOM LATIN EST LE PREMIER NOM DE LA COLONNE "Nom_Taxon_Cite
# SI LE NOM CONTIENT UN "|", LE NOM LATIN EST LE PREMIER NOM AVANT LE "|"

# Diviser les noms
my_split <- function(array, str = " \\| ") {
  out <- rep(NA, length(array))
  for (i in 1:length(array)) {
    out[i] <- unlist(strsplit(array[i], str))[1]
  }
  return(out)
}

# Tester la fonction
only_latin <- my_split(as.vector(oiseaux$Nom_Taxon_Cite))

# On ajoute la nouvelle colonne au dataframe
oiseaux$latin <- only_latin
```

On affiche le tableau qui représente le MOS11 pour chaque station de mesure.
```{r}
# CRÉER UNE NOUVELLE COLONNE DANS LE DATAFRAME OISEAUX QUI CONTIENT LA VALEUR MOS11 DU POINT
filter <- LUP$BufferSize == 500
LUP_500_MOS11 <- LUP[filter, c("Geometry", "ID", "X", "Y", "BufferSize", "MOS11")]
rownames(LUP_500_MOS11) <- 1:nrow(LUP_500_MOS11)
LUP_500_MOS11[, c("ID", "MOS11")]

MOS11 <- rep(NA, nrow(oiseaux))
for (i in 1:nrow(oiseaux)) {
  MOS11[i] <- which(oiseaux$Code_Maille[i] == LUP_500_MOS11$ID)
}

# Ajouter la colonne MOS11 au dataframe
oiseaux$MOS11 <- LUP_500_MOS11$MOS11[MOS11]
```


# On fait la carte


```{r}
traits <- read.csv("data/birds/traits-statut-IUCN-biodivercite.csv", header = TRUE)
cite <- read.csv("data/birds/BiodiverCite_sites.csv", header = TRUE, sep = ";")

#on veut traiter la table dénombrement qu"on appelera denombrementCarte où il restera pour chaque maille et pour chaque année le top 3 des oiseaux les plus observés sans la variable p

denombrementCarte <- denombrement %>%
  group_by(Code_Maille, annee) %>%
  top_n(3, sum) %>%
  arrange(Code_Maille, annee, desc(sum)) %>%
  ungroup() %>%
  select(-p)


#on veut changer cette table pour faire apparaitre de nouvelles colonnes pour qu"il y ait : une ligne par maille et par année, et pour chaque oiseau, le nombre d"individus observés

denombrementCarte <- denombrementCarte %>%
  pivot_wider(names_from = latin, values_from = sum, values_fill = 0)


#on veut ajouter les colonnes geometry, buffer size et MOS11 à la table denombrementCarte et pas les autres

denombrementCarte <- left_join(denombrementCarte, LUP, by = c("Code_Maille" = "ID"))

#on enlève les colonnes : MOS1, MOS2, MOS3, MOS4, MOS5, MOS6, MOS7, MOS8, MOS9, MOS10, MOS12, MOS13, MOS14

denombrementCarte <- denombrementCarte %>%
  select(-c(MOS1, MOS2, MOS3, MOS4, MOS5, MOS6, MOS7, MOS8, MOS9, MOS10, MOS12, MOS13, MOS14))

# On garde que les lignes ou BufferSize == 500
denombrementCarte <- denombrementCarte %>%
  filter(BufferSize == 500)

denombrementCarte <- st_as_sf(denombrementCarte, coords = c("X", "Y"), crs = 2154)
denombrementCarte <- st_transform(denombrementCarte, crs = 4326)

# On garde seuelement les valeurs ou annee = 2018

denombrementCarte <- denombrementCarte %>%
  filter(annee == 2023)

denombrementCarte

```
Grâce à ce tableau, nous pouvons voir comment les données sont structurées et remarquer notamment qu'il classe le nombre d'oiseaux par maille et par année.


Voici la carte interactive qui montre les mailles de mesure et les oiseaux les plus observés dans chaque maille.
```{r}
# On garder que les colonnes qui nous intéressent, cad code_site et Nom_lieu
cite <- cite %>%
  select(code_site, Nom_lieu)

#On join les deux tables cite et denombrementCarte

denombrementCarte <- left_join(denombrementCarte, cite, by = c("Code_Maille" = "code_site"))

# Créer une chaîne de caractères pour les popups avec le top trois des oiseaux ayant la plus grande valeur
denombrementCarte$popup_text <- paste0("<strong>Maille:</strong> ", denombrementCarte$Nom_lieu, "<br>",
                                       "<strong>Année:</strong> ", denombrementCarte$annee, "<br>",
                                       "<strong>Top 3 des oiseaux:</strong>", "<br>")

dataframe <- as.data.frame(denombrementCarte)

# On enleve les colonnes Code_Maille, annee, BufferSize, MOS11, Geometry, geometry
dataframe <- dataframe %>%
  select(-c(Code_Maille, annee, BufferSize, MOS11, Geometry, geometry, Nom_lieu))

# Ajouter les noms des oiseaux et leurs valeurs au popup_text pour chaque ligne
for (i in 1:nrow(dataframe)) {
  top_birds <- sort(unlist(dataframe[i, -c(ncol(dataframe))]), decreasing = TRUE)[1:3]
  top_bird_names <- names(top_birds)
  denombrementCarte$popup_text[i] <- paste0(denombrementCarte$popup_text[i],
                                            top_bird_names[1], ": ", top_birds[1], " - ", traits[which(traits$Nom.latin == top_bird_names[1]), "Niveau.de.spécialisation"], "<br>",
                                            top_bird_names[2], ": ", top_birds[2], " - ", traits[which(traits$Nom.latin == top_bird_names[2]), "Niveau.de.spécialisation"], "<br>",
                                            top_bird_names[3], ": ", top_birds[3], " - ", traits[which(traits$Nom.latin == top_bird_names[3]), "Niveau.de.spécialisation"])
}

pal <- colorNumeric("viridis", domain = denombrementCarte$MOS11)


leaflet(data = denombrementCarte) %>%
  addProviderTiles("CartoDB.Positron") %>%
  addCircles(radius = 300, color = ~pal(MOS11), fillOpacity = 0.2, popup = ~popup_text) %>%
  addLegend("bottomright", pal = pal, values = ~MOS11, title = "MOS11", position = "bottomright") %>%
  addScaleBar(position = "bottomleft")
```
Grâce à cette carte, nous obtenons le classement (Top 3) des oiseaux les plus observés dans chaque maille de mesure pour l'année 2023.
Nous avons également ajouté une information supplémentaire sur chaque oiseau pour mettre en évidence son niveau de spécialisation afin de mieux comprendre de quel type de milieu il a besoin pour vivre et la géolocalisation sur la Gironde.

Il nous semblait intéressant de savoir quels étaient les régimes alimentaires majoritaires principaux en fonction de chaque maille.
Nous avons donc créé un graphique qui montre la répartition des régimes alimentaires pour chaque maille.

```{r}
oiseaux <- read.csv("data/birds/Oiseaux_up_to_2023.csv", header = TRUE, sep = "\t")
my_split <- function(array, str = " \\| ") {
  out <- rep(NA, length(array))
  for (i in 1:length(array)) {
    out[i] <- unlist(strsplit(array[i], str))[1]
  }
  return(out)
}

only_latin <- my_split(as.vector(oiseaux$Nom_Taxon_Cite))

oiseaux$latin <- only_latin
oiseaux$annee <- as.numeric(substr(oiseaux$Date, 1, 4))

denombrement <- oiseaux %>%
  group_by(Code_Maille, annee, latin) %>%
  summarise(sum = sum(Denombrement_min, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(Code_Maille))

denombrement$p <- rep(NA, nrow(denombrement))
for (i in 1:nrow(denombrement)) {
  numerator <- denombrement$sum[i]
  denominator <-
    sum(denombrement$sum[which(denombrement$Code_Maille == denombrement$Code_Maille[i]
                               & denombrement$annee == denombrement$annee[i])])
  denombrement$p[i] <- numerator / denominator
}

index <- denombrement %>%
  group_by(Code_Maille, annee = factor(annee)) %>%
  summarise(D1 = sum(p > 0, na.rm = TRUE),
            D2 = exp(-sum(p * log(p))),
            D3 = 1 / sum(p^2), .groups = "drop") %>%
  arrange(desc(Code_Maille))

LUP <- read.csv("data/birds/LandUsePer_BM_2023_cartoISea.csv", header = TRUE)
index$MOS11 <- rep(NA, nrow(index))
for (i in 1:nrow(index)) {
  index$MOS11[i] <- LUP$MOS11[which(index$Code_Maille[i] == LUP$ID & LUP$BufferSize == 500)]
}
```

```{r}
# changed the unmatchinng latin names to the correct ones to match alimentation
denombrement$latin[denombrement$latin == "Carduelis chloris"] <- "Chloris chloris"
denombrement$latin[denombrement$latin == "Carduelis spinus"] <- "Spinus spinus"
denombrement$latin[denombrement$latin == "Casmerodius albus"] <- "Ardea alba"
denombrement$latin[denombrement$latin == "Carduelis cannabina"] <- "Linaria cannabina"
no_info <- c("Himantopus himantopus", "Tringa ochropus",
             "Caprimulgus europaeus", "Lanius senator",
             "Dryocopus martius", "Emberiza calandra")

alimentation <- read.csv("data/birds/traits-statut-IUCN-biodivercite.csv", header = TRUE)
denombrement$regime_alimentaire <- rep(NA, nrow(denombrement))
for (i in 1:nrow(denombrement)) {
  if (denombrement$latin[i] %in% no_info) {
    denombrement$regime_alimentaire[i] <- NA
  } else {
    denombrement$regime_alimentaire[i] <-
      alimentation$Régime.alimentaire[which(alimentation$Nom.latin == denombrement$latin[i])]
  }
}
denombrement$regime_alimentaire <- as.factor(denombrement$regime_alimentaire)

plot_data <- function(data, title) {
  ggplot(data, aes(x = "", y = sum, fill = regime_alimentaire)) +
    geom_bar(stat = "identity", width = 0.1) +
    coord_polar("y", start = 0) +
    ggtitle(paste("Station: ", as.character(title))) +
    theme_void()
}

N <- length(unique(denombrement$Code_Maille))
p <- vector("list", length = N)

for (i in 1:N) {
  data <- denombrement[which(denombrement$Code_Maille == unique(denombrement$Code_Maille)[i]), ]
  data <- data %>% group_by(regime_alimentaire) %>% summarise(sum = sum(p, na.rm = TRUE))
  p[[i]] <- plot_data(data, unique(denombrement$Code_Maille)[i])
}

coordinates <- st_as_sf(LUP, coords = c("X", "Y"), crs = 2154)
coordinates <- st_transform(coordinates, crs = 4326)
coordinates <- coordinates[coordinates$BufferSize == 500, ]

# Remove the coordinates that are not in denombrement
for (i in seq_along(coordinates$ID)){
  if (!(coordinates$ID[i] %in% unique(denombrement$Code_Maille))) {
    coordinates <- coordinates[-i, ]
  }
}

coordinates <- coordinates[order(coordinates$ID, decreasing = TRUE), ]

pal <- colorNumeric("viridis", domain = coordinates$MOS11)
leaflet(data = coordinates) %>%
  addProviderTiles("CartoDB.Positron") %>%
  addCircles(radius = 300, color = ~pal(MOS11),
             fillOpacity = 0.5, group = "pnt") %>%
  addLegend("bottomright", pal = pal, values = coordinates$MOS11, title = "MOS11") %>%
  addScaleBar(position = "bottomleft") %>%
  addPopupGraphs(p, width = 200, height = 200, group = "pnt")
```

Voici à quoi ressemble la carte interactive qui montre les régimes alimentaires majoritaires principaux en fonction de chaque maille.

<!--
  ```{r}
  denombrement$Nidification <- rep(NA, nrow(denombrement))
  for (i in 1:nrow(denombrement)) {
    if (denombrement$latin[i] %in% no_info) {
      denombrement$Nidification[i] <- NA
    } else {
      denombrement$Nidification[i] <-
        alimentation$Nidification[which(alimentation$Nom.latin == denombrement$latin[i])]
  }
  denombrement$Nidification <- as.factor(denombrement$Nidification)

  plot_data <- function(data, title) {
    ggplot(data, aes(x = "", y = sum, fill = Nidification)) +
      geom_bar(stat = "identity", width = 0.1) +
      coord_polar("y", start = 0) +
      ggtitle(paste("Station: ", as.character(title))) +
      theme_void()
  }

  #On join les deux tables cite et denombrementCarte

  N <- length(unique(denombrement$Code_Maille))
  p <- vector("list", length = N)

  for (i in 1:N) {
    data <- denombrement[which(denombrement$Code_Maille == unique(denombrement$Code_Maille)[i]), ]
    data <- data %>% group_by(Nidification) %>% summarise(sum = sum(p, na.rm = TRUE))
    p[[i]] <- plot_data(data, unique(denombrement$Nom_lieu)[i])
  }

  coordinates <- st_as_sf(LUP, coords = c("X", "Y"), crs = 2154)
  coordinates <- st_transform(coordinates, crs = 4326)
  coordinates <- coordinates[coordinates$BufferSize == 500, ]

  # Remove the coordinates that are not in denombrement
  for (i in seq_along(coordinates$ID)){
    if (!(coordinates$ID[i] %in% unique(denombrement$Code_Maille))) {
      coordinates <- coordinates[-i, ]
    }
  }

  coordinates <- coordinates[order(coordinates$ID, decreasing = TRUE), ]

  pal <- colorNumeric("viridis", domain = coordinates$MOS11)
  leaflet(data = coordinates) %>%
    addProviderTiles("CartoDB.Positron") %>%
    addCircles(radius = 300, color = ~pal(MOS11),
              fillOpacity = 0.5, group = "pnt") %>%
    addLegend("bottomright", pal = pal, values = coordinates$MOS11, title = "MOS11") %>%
    addScaleBar(position = "bottomleft") %>%
    addPopupGraphs(p, width = 200, height = 200, group = "pnt")
  ```
-->

# Pey-PeyBerland

```{r}
# Maintenant on va faire un datframe qui calcule les distances de toues les stations code_maille avec le centre ville, en considérant que le centre ville est PeyBerland

# On donne la cordonnée de PeyBerland (latitude et longitude) afin de calculer les distances par la suite avec sf
# lat = 44.838168 et long = -0.578803

PeyBerland <- data.frame("Latitude" = 44.838168, "Longitude" = -0.578803)

# On convertit les coordonnées de PeyBerland en sf

PeyBerland <- st_as_sf(PeyBerland, coords = c("Longitude", "Latitude"), crs = 4326)

# On va créer un dataframe qui contient les coordonnées de toutes les stations code_maille

coordinates <- st_as_sf(LUP, coords = c("X", "Y"), crs = 2154)

# On va transformer les coordonnées de 2154 à 4326

coordinates <- st_transform(coordinates, crs = 4326)

# On va calculer les distances entre les stations et le centre ville PeyBerland

coordinates$Distance <- st_distance(coordinates, PeyBerland)
```

```{r, message=FALSE}
denombrement <- oiseaux %>%
  group_by(Code_Maille, annee, latin) %>%
  summarise(sum = sum(Denombrement_min, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(Code_Maille))

denombrement$p <- rep(NA, nrow(denombrement))
for (i in 1:nrow(denombrement)) {
  numerator <- denombrement$sum[i]
  denominator <-
    sum(denombrement$sum[which(denombrement$Code_Maille == denombrement$Code_Maille[i]
                               & denombrement$annee == denombrement$annee[i])])
  denombrement$p[i] <- numerator / denominator
}

index <- denombrement %>%
  group_by(Code_Maille, annee = factor(annee)) %>%
  summarise(D1 = sum(p > 0, na.rm = TRUE),
            D2 = exp(-sum(p * log(p))),
            D3 = 1 / sum(p^2), .groups = "drop") %>%
  arrange(desc(Code_Maille))

LUP <- read.csv("data/birds/LandUsePer_BM_2023_cartoISea.csv", header = TRUE)
index$Distance <- rep(NA, nrow(index))
for (i in 1:nrow(index)) {
  index$Distance[i] <- coordinates$Distance[which(index$Code_Maille[i] == coordinates$ID & coordinates$BufferSize == 500)]
}

par(mfrow = c(1, 3))
```

```{r}
ggplot(index, aes(x = Distance, y = D1, color = as.factor(annee))) +
  geom_point(size = 2) +
  geom_smooth(method = "auto", se = TRUE, color = "black", alpha = 0.2) +
  labs(title = "D1 en fonction de la distance au centre-ville",
       x = "Distance",
       y = "D1") +
  theme_minimal() +
  theme(legend.position = "bottom")
```

```{r}
ggplot(index, aes(x = Distance, y = D2, color = as.factor(annee))) +
  geom_point(size = 2) +
  geom_smooth(method = "auto", se = TRUE, color = "black", alpha = 0.2) +
  labs(title = "D2 en fonction de la distance au centre-ville",
       x = "Distance",
       y = "D2") +
  theme_minimal() +
  theme(legend.position = "bottom")
```

```{r}
ggplot(index, aes(x = Distance, y = D3, color = as.factor(annee))) +
  geom_point(size = 2) +
  geom_smooth(method = "auto", se = TRUE, color = "black", alpha = 0.2) +
  labs(title = "D3 en fonction de la distance au centre-ville",
       x = "Distance",
       y = "D3") +
  theme_minimal() +
  theme(legend.position = "bottom")
```


# ACP

```{r}
pca_result <- PCA(LUP[, 6:19], scale.unit = TRUE, graph = FALSE)
fviz_eig(
  pca_result,
  addlabels = TRUE,
  ncp = 14
)
```

```{r}
fviz_pca_var(
  pca_result,
  col.var = "contrib",
  gradient.cols = rainbow(5),
  legend.title = "Contribution (%)",
  repel = TRUE
)
```

```{r}
fviz_pca_ind(
  pca_result,
  repel = FALSE
)
fviz_pca_biplot(
  pca_result,
  repel = FALSE,
  col.var = "#E50000"
)
```

```{r}
birds_info <- read.csv("data/birds/traits-statut-IUCN-biodivercite.csv", header = TRUE)
birds_info <- birds_info[, c(
  "Nom.latin",
  "Niveau.de.spécialisation",
  "Régime.alimentaire",
  "Technique.d.alimentation",
  "Nidification",
  "Période.de.migration"
)]

denombrement
LUP
```

```{r}
unique_level <- unique(birds_info[, "Niveau.de.spécialisation"])
unique_regime <- unique(birds_info[, "Régime.alimentaire"])
unique_technique <- unique(birds_info[, "Technique.d.alimentation"])
unique_nidi <- unique(birds_info[, "Nidification"])
unique_migration <- unique(birds_info[, "Période.de.migration"])

plot_ly(data.frame(), type = "parcoords", line = list(color = "blue"), height = 950,
  dimensions = list(
    list(
      label = "Espèces",
      range = c(1, length(birds_info[, "Nom.latin"])),
      tickvals = 1:length(birds_info[, "Nom.latin"]),
      ticktext = birds_info[, "Nom.latin"],
      values = 1:length(birds_info[, "Nom.latin"])
    ),
    list(
      label = "Technique d'alimentation",
      range = c(1, length(unique_technique)),
      tickvals = 1:length(unique_technique),
      ticktext = unique_technique,
      values = as.numeric(factor(birds_info[, "Technique.d.alimentation"]))
    ),
    list(
      label = "Nidification",
      range = c(1, length(unique_nidi)),
      tickvals = 1:length(unique_nidi),
      ticktext = unique_nidi,
      values = as.numeric(factor(birds_info[, "Nidification"]))
    ),
    list(
      label = "Niveau de spécialisation",
      range = c(1, length(unique_level)),
      tickvals = 1:length(unique_level),
      ticktext = unique_level,
      values = as.numeric(factor(birds_info[, "Niveau.de.spécialisation"]))
    ),
    list(
      label = "Période de migration",
      range = c(1, length(unique_migration)),
      tickvals = 1:length(unique_migration),
      ticktext = unique_migration,
      values = as.numeric(factor(birds_info[, "Période.de.migration"]))
    ),
    list(
      label = "Régime alimentaire",
      range = c(1, length(unique_regime)),
      tickvals = 1:length(unique_regime),
      ticktext = unique_regime,
      values = as.numeric(factor(birds_info[, "Régime.alimentaire"]))
    )
  )
) %>% layout(
  title = "Caractéristiques des différentes espèces d'oiseaux",
  margin = list(l = 140, r = 55)
)
```